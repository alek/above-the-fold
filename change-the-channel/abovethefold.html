<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>PNG Viewer with Scanner & MIDI Controls</title>
  <style>
    body { 
      margin: 0; 
      overflow: hidden; 
      background: black; 
      display: flex; 
      align-items: center; 
      justify-content: center;
    }
    canvas { display: block; }
  </style>
</head>
<body>
  <canvas id="glCanvas"></canvas>
  <script>
    // ---------------------------
    // Global State and Variables
    // ---------------------------
    let imageList = [];
    let currentIndex = 0;
    let gl, texture, shaderProgram, canvas;
    let imageWidth = 0, imageHeight = 0;
    
    // --- Scan Effect Variables ---
    // baseScanBegin is the base row (in pixels) where scanning begins.
    let baseScanBegin = 500; 
    // scanOffset increases over time to animate the scan.
    let scanOffset = 0;
    // scanSpeed (pixels per frame), controlled by MIDI channel 2.
    let scanSpeed = 1;
    // Flag to pause scanning (toggled by the "P" key).
    let scanningPaused = false;
    
    // --- Horizontal Scrolling ---
    // Off by default.
    let scrollActive = false;
    // Horizontal offset (normalized 0â€“1).
    let offset = 0;
    // scrollSpeed: positive means slide right.
    let scrollSpeed = 0.002;
    let autoTimer;
    
    // Additional visual effects (controlled by MIDI):
    let distortionAmount = 0.0; // Channel 3: per-pixel distortion factor.
    let invertValue = 0.0;      // Channel 4: inversion blend (0 = none, 255 = full inversion).
    let glitchAmount = 0.0;     // Channel 7: overall glitch factor.
    
    // For image index jumps (MIDI channels 5 & 6).
    let midiTriggers = {5: false, 6: false};
    let baseJumpValue = 0;
    
    // Transformation matrix for centering.
    let transformMatrix = new Float32Array(16);
    const config = { randomOrder: false };
    
    // ---------------------------
    // Image Fetching and Navigation
    // ---------------------------
    async function fetchImages() {
      const response = await fetch("http://localhost:3001/list-images");
      imageList = await response.json();
      if (config.randomOrder) { shuffleArray(imageList); }
      loadNextImage();
      startAutoTimer();
      setInterval(updateScannerEffect, 16);
      window.addEventListener("resize", onWindowResize);
    }
    
    function onWindowResize() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      updateTransform();
      drawScene();
    }
    
    function startAutoTimer() {
      setTimeout(() => {
        currentIndex = (currentIndex + 1) % imageList.length;
        loadNextImage();
        startAutoTimer();
      }, 59000);
    }
    
    function loadNextImage() {
      if (imageList.length === 0) return;
      loadTexture(`http://localhost:3001/images/${imageList[currentIndex]}`);
    }
    
    function shuffleArray(array) {
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
    }
    
    // ---------------------------
    // WebGL Initialization & Shaders
    // ---------------------------
    function initWebGL() {
      canvas = document.getElementById("glCanvas");
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      gl = canvas.getContext("webgl");
      if (!gl) {
        console.error("WebGL not supported");
        return;
      }
      const vertexShaderSource = `
        attribute vec4 a_position;
        attribute vec2 a_texCoord;
        uniform mat4 u_transform;
        varying vec2 v_texCoord;
        void main() {
          gl_Position = u_transform * a_position;
          v_texCoord = a_texCoord;
        }
      `;
      /* Fragment shader:
         - u_scanLine: normalized source row (computed from (baseScanBegin + scanOffset) / imageHeight).
         - u_scanThreshold: normalized cutoff at which the scan effect begins.
           Here we set u_scanThreshold equal to u_scanLine so that pixel copying starts
           exactly at the scanned row.
         - For fragments with v_texCoord.y less than u_scanThreshold, the shader samples from the texture
           at (x, u_scanLine) with noise distortion and inversion applied.
         - Otherwise, the original pixel is shown (with an overall glitch offset).
      */
      const fragmentShaderSource = `
        precision mediump float;
        varying vec2 v_texCoord;
        uniform sampler2D u_texture;
        uniform float u_scanLine;
        uniform float u_scanThreshold;
        uniform float u_offset;
        uniform float u_distortion;
        uniform float u_invert;
        uniform float u_glitch;
        float rand(vec2 co) {
          return fract(sin(dot(co.xy, vec2(12.9898,78.233))) * 43758.5453);
        }
        void main(){
          float glitchVal = rand(v_texCoord * 100.0) * u_glitch;
          vec2 shiftedTexCoord = vec2(mod(v_texCoord.x + u_offset + glitchVal, 1.0), v_texCoord.y);
          vec4 originalPixel = texture2D(u_texture, shiftedTexCoord);
          if(v_texCoord.y < u_scanThreshold) {
            float noiseVal = rand(v_texCoord * 10.0);
            vec2 copyCoord = vec2(mod(v_texCoord.x + u_offset + noiseVal * u_distortion, 1.0), u_scanLine);
            vec4 copiedPixel = texture2D(u_texture, copyCoord);
            float invFactor = u_invert / 255.0;
            gl_FragColor = mix(copiedPixel, vec4(1.0 - copiedPixel.rgb, copiedPixel.a), invFactor);
          } else {
            gl_FragColor = originalPixel;
          }
        }
      `;
      const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
      const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
      shaderProgram = createProgram(gl, vertexShader, fragmentShader);
      gl.useProgram(shaderProgram);
      setupBuffers();
      updateTransform();
    }
    
    function setupBuffers() {
      const positionBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
         -1, -1,   1, -1,   -1,  1,
         -1,  1,   1, -1,    1,  1,
      ]), gl.STATIC_DRAW);
      
      const texCoordBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
         0, 1,   1, 1,   0, 0,
         0, 0,   1, 1,   1, 0,
      ]), gl.STATIC_DRAW);
      
      const posLoc = gl.getAttribLocation(shaderProgram, "a_position");
      gl.enableVertexAttribArray(posLoc);
      gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
      gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);
      
      const texLoc = gl.getAttribLocation(shaderProgram, "a_texCoord");
      gl.enableVertexAttribArray(texLoc);
      gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
      gl.vertexAttribPointer(texLoc, 2, gl.FLOAT, false, 0, 0);
      
      texture = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, texture);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    }
    
    function createShader(gl, type, source) {
      const shader = gl.createShader(type);
      gl.shaderSource(shader, source);
      gl.compileShader(shader);
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        console.error("Shader compilation failed:", gl.getShaderInfoLog(shader));
        gl.deleteShader(shader);
        return null;
      }
      return shader;
    }
    
    function createProgram(gl, vertexShader, fragmentShader) {
      const program = gl.createProgram();
      gl.attachShader(program, vertexShader);
      gl.attachShader(program, fragmentShader);
      gl.linkProgram(program);
      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        console.error("Program linking failed:", gl.getProgramInfoLog(program));
        return null;
      }
      return program;
    }
    
    function loadTexture(imageUrl) {
      const img = new Image();
      img.crossOrigin = "anonymous";
      img.onload = function () {
        imageWidth = img.width;
        imageHeight = img.height;
        // Set default base scan parameters.
        baseScanBegin = imageHeight * 0.5; // initial scan line (in pixels)
        baseScanEnd = baseScanBegin;       // threshold equals scan line so effect starts exactly here
        // Reset vertical scan offset.
        scanOffset = 0;
        updateTransform();
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img);
        gl.generateMipmap(gl.TEXTURE_2D);
        drawScene();
      };
      img.src = imageUrl;
    }
    
    // ---------------------------
    // Update Functions
    // ---------------------------
    function updateScannerEffect() {
      if (!scanningPaused) {
        scanOffset += scanSpeed;
        // Reset scanOffset when it reaches a full cycle relative to baseScanBegin.
        if (scanOffset >= imageHeight - baseScanBegin) {
          scanOffset = 0;
        }
      }
      // Compute the current scanner row:
      let scannerRow = (baseScanBegin + scanOffset) % imageHeight;
      let normScannerRow = scannerRow / imageHeight;
      
      // Set both u_scanLine and u_scanThreshold to normScannerRow so that
      // the copying of pixels starts exactly at the scanned row.
      gl.uniform1f(gl.getUniformLocation(shaderProgram, "u_scanLine"), normScannerRow);
      gl.uniform1f(gl.getUniformLocation(shaderProgram, "u_scanThreshold"), normScannerRow);
      
      if (scrollActive) {
        offset -= scrollSpeed;
        if (offset >= 1.0) { offset += 1.0; }
        if (offset < 0) { offset -= 1.0; }
      }
      gl.uniform1f(gl.getUniformLocation(shaderProgram, "u_offset"), offset);
      
      gl.uniform1f(gl.getUniformLocation(shaderProgram, "u_distortion"), distortionAmount);
      gl.uniform1f(gl.getUniformLocation(shaderProgram, "u_invert"), invertValue);
      gl.uniform1f(gl.getUniformLocation(shaderProgram, "u_glitch"), glitchAmount);
      
      drawScene();
    }
    
    function updateTransform() {
      const transformLoc = gl.getUniformLocation(shaderProgram, "u_transform");
      let cw = canvas.width, ch = canvas.height;
      let scaleX = imageWidth / cw, scaleY = imageHeight / ch;
      let m = new Float32Array([
         scaleX, 0, 0, 0,
         0, scaleY, 0, 0,
         0, 0, 1, 0,
         0, 0, 0, 1
      ]);
      gl.uniformMatrix4fv(transformLoc, false, m);
    }
    
    function drawScene() {
      gl.clear(gl.COLOR_BUFFER_BIT);
      gl.viewport(0, 0, canvas.width, canvas.height);
      gl.drawArrays(gl.TRIANGLES, 0, 6);
    }
    
    // ---------------------------
    // Keyboard Controls
    // ---------------------------
    window.addEventListener("keydown", function (e) {
      switch(e.code) {
        case "ArrowLeft":
          e.preventDefault();
          if(e.shiftKey) {
            currentIndex = Math.max(0, currentIndex - 100);
          } else {
            currentIndex = (currentIndex - 1 + imageList.length) % imageList.length;
          }
          loadNextImage();
          break;
        case "ArrowRight":
          e.preventDefault();
          if(e.shiftKey) {
            currentIndex = Math.min(imageList.length - 1, currentIndex + 100);
          } else {
            currentIndex = (currentIndex + 1) % imageList.length;
          }
          loadNextImage();
          break;
        case "Space":
          e.preventDefault();
          // When Space is pressed:
          // If scrolling is off, turn it on (slide to right); if already on, turn it off.
          scrollActive = !scrollActive;
          if(scrollActive) {
            scrollSpeed = Math.abs(scrollSpeed); // ensure positive for sliding right
          }
          break;
        case "KeyP":
          e.preventDefault();
          scanningPaused = !scanningPaused;
          break;
        case "KeyQ":
          scanSpeed = Math.max(1, scanSpeed - 0.5);
          break;
        case "KeyW":
          scanSpeed += 0.5;
          break;
        case "KeyA":
          scrollSpeed = Math.max(0.0005, scrollSpeed - 0.0005);
          break;
        case "KeyS":
          scrollSpeed += 0.0005;
          break;
        case "KeyZ":
          scanOffset = 0;
          break;
      }
    });
    
    // ---------------------------
    // MIDI Integration
    // ---------------------------
    window.onload = function () {
      initWebGL();
      fetchImages();
      
      const midiWs = new WebSocket("ws://localhost:8080/midi/stream");
      midiWs.onmessage = function(event) {
        const message = event.data.trim();
        const match = message.match(/pitchwheel channel=(\d+) pitch=(-?\d+)/);
        if (!match) return;
        const channel = parseInt(match[1]);
        const pitch = parseInt(match[2]);
        const normalized = (pitch + 8192) / (8192 + 8064);
        switch(channel) {
          case 0:
            // Optionally, adjust baseScanBegin via MIDI channel 0.
            if(imageHeight) { baseScanBegin = normalized * imageHeight; }
            break;
          case 1:
            // Adjust baseScanEnd (threshold) via MIDI channel 1.
            if(imageHeight) { baseScanEnd = normalized * imageHeight; }
            break;
          case 2:
            // Set scan speed (range: 1 to 10 pixels per frame).
            scanSpeed = 1 + normalized * 9;
            break;
          case 3:
            distortionAmount = normalized;
            break;
          case 4:
            invertValue = normalized * 255;
            break;
          case 5:
            if(normalized > 0.5 && !midiTriggers[5]) {
              baseJumpValue = Math.floor(normalized * 40);
              currentIndex = (currentIndex + baseJumpValue) % imageList.length;
              loadNextImage();
              midiTriggers[5] = true;
            } else if(normalized <= 0.5) {
              midiTriggers[5] = false;
            }
            break;
          case 6:
            if(normalized > 0.5 && !midiTriggers[6]) {
              let fineJump = Math.floor(normalized * 40);
              currentIndex = (currentIndex + baseJumpValue + fineJump) % imageList.length;
              loadNextImage();
              midiTriggers[6] = true;
            } else if(normalized <= 0.5) {
              midiTriggers[6] = false;
            }
            break;
          case 7:
            glitchAmount = normalized * 1.1;
            break;
        }
      };
    };
  </script>
</body>
</html>
